#### JVM

 jvm:

 https://blog.csdn.net/qq_41701956/article/details/81664921 

##### jvm分区: 

  ![1589601872275](D:\iVscodeWork\javaInterview\资料整理\1589601872275.png)

 

1.  程序计数器: 内存空间小，线程私有。字节码解释器工作是就是通过改变这个计数器的值来选取下一条需要执行指令的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器完成 
2.   Java 虚拟机栈 : 线程私有，生命周期和线程一致。描述的是 Java 方法执行的内存模型：每个方法在执行时都会床创建一个栈帧(Stack Frame)用于存储`局部变量表`、`操作数栈`、`动态链接`、`方法出口`等信息。每一个方法从调用直至执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程。 
3.  本地方法栈 :区别于 Java 虚拟机栈的是，Java 虚拟机栈为虚拟机执行 Java 方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。也会有 StackOverflowError 和 OutOfMemoryError 异常。 

4.   Java 堆 :对于绝大多数应用来说，这块区域是 JVM 所管理的内存中最大的一块。线程共享，主要是存放对象实例和数组。内部会划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer, TLAB)。可以位于物理上不连续的空间，但是逻辑上要连续。 
5.   方法区 : 属于共享内存区域，存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 

#####  对象创建的过程:

  遇到 new 指令时，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，执行相应的类加载。

类加载检查通过之后，为新对象分配内存(内存大小在类加载完成后便可确认)。在堆的空闲内存中划分一块区域(‘指针碰撞-内存规整’或‘空闲列表-内存交错’的分配方式)。

前面讲的每个线程在堆中都会有私有的分配缓冲区(TLAB)，这样可以很大程度避免在并发情况下频繁创建对象造成的线程不安全。

内存空间分配完成后会初始化为 0(不包括对象头)，接下来就是填充对象头，把对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息存入对象头。

执行 new 指令后执行 init 方法后才算一份真正可用的对象创建完成。

#####  如何判断对象可回收:

 引用计数法 : 给对象添加一个引用计数器。引用数为0标记可回收, 但是难以解决循环引用问题。 

 可达性分析法 :  通过一系列的 ‘GC Roots’ 的对象作为起始点，从这些节点出发所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连的时候说明对象不可用。

##### 堆的内存模型:

 新生代 GC (Minor GC) :  发生在新生代的垃圾回收动作，频繁，速度快。 

 老年代 GC (Major GC / Full GC) : 发生在老年代的垃圾回收动作，出现了 Major GC 经常会伴随至少一次 Minor GC(非绝对)。Major GC 的速度一般会比 Minor GC 慢十倍以上。 

>2.6.2 大对象直接进入老年代
>
>2.6.3 长期存活的对象将进入老年代
>
>2.6.4 动态对象年龄判定
>
>2.6.5 空间分配担保

##### 回收算法:

  标记--清除算法: 直接标记清除就可。 

  复制算法 : 把空间分成两块，每次只对其中一块进行 GC。当这块内存使用完时，就将还存活的对象复制到另一块上面 

 标记-整理算法 :   不同于针对新生代的复制算法，针对老年代的特点，创建该算法。主要是把存活对象移到内存的一端。 

 分代回收:  根据存活对象划分几块内存区，一般是分为新生代和老年代。然后根据各个年代的特点制定相应的回收算法。 

#####  内存泄漏解决方案:

#####  https://www.cnblogs.com/jvStarBlog/p/11688313.html  

1. top 查看内存占用
2.  jstack 抓java 线程,
3. jprofiler 查看对象占用,分析为什么没有回收

常问的问题:

 https://blog.csdn.net/qq_41701956/article/details/100074023 

##### 1.什么情况下会发生栈内存溢出。

栈是线程私有的，他的生命周期与线程相同，每个方法在执行的时候都会创建一个栈帧，用来存储局部变量表，操作数栈，动态链接，方法出口等信息。局部变量表又包含基本数据类型，对象引用类型
如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常，方法递归调用产生这种结果。
如果Java虚拟机栈可以动态扩展，并且扩展的动作已经尝试过，但是无法申请到足够的内存去完成扩展，或者在新建立线程的时候没有足够的内存去创建对应的虚拟机栈，那么Java虚拟机将抛出一个OutOfMemory 异常。(线程启动过多)
参数 -Xss 去调整JVM栈的大小

##### 2.详解JVM内存模型

程序计数器：当前线程所执行的字节码的行号指示器，用于记录正在执行的虚拟机字节指令地址，线程私有。

Java虚拟栈：存放基本数据类型、对象的引用、方法出口等，线程私有。

Native方法栈：和虚拟栈相似，只不过它服务于Native方法，线程私有。

Java堆：java内存最大的一块，所有对象实例、数组都存放在java堆，GC回收的地方，线程共享。

方法区：存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码数据等。（即永久带），回收目标主要是常量池的回收和类型的卸载，各线程共享

##### 3.JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。

思路： 先讲一下JAVA堆，新生代的划分，再谈谈它们之间的转化，相互之间一些参数的配置（如： –XX:NewRatio，–XX:SurvivorRatio等），再解释为什么要这样划分，最好加一点自己的理解。

我的答案：

1）共享内存区划分

共享内存区 = 持久带 + 堆
持久带 = 方法区 + 其他
Java堆 = 老年代 + 新生代
新生代 = Eden + S0 + S1
2）一些参数的配置

默认的，新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ，可以通过参数 –XX:NewRatio 配置。
默认的，Edem : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定)
Survivor区中的对象被复制次数为15(对应虚拟机参数 -XX:+MaxTenuringThreshold)
3)为什么要分为Eden和Survivor?为什么要设置两个Survivor区？

如果没有Survivor，Eden区每进行一次Minor GC，存活的对象就会被送到老年代。老年代很快被填满，触发Major GC.老年代的内存空间远大于新生代，进行一次Full GC消耗的时间比Minor GC长得多,所以需要分为Eden和Survivor。
Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。
设置两个Survivor区最大的好处就是解决了碎片化，刚刚新建的对象在Eden中，经历一次Minor GC，Eden中的存活对象就会被移动到第一块survivor space S0，Eden被清空；等Eden区再满了，就再触发一次Minor GC，Eden和S0中的存活对象又会被复制送入第二块survivor space S1（这个过程非常重要，因为这种复制算法保证了S1中来自S0和Eden两部分的存活对象占用连续的内存空间，避免了碎片化的发生）

4. ##### JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代

  思路： 先描述一下Java堆内存划分，再解释Minor GC，Major GC，full GC，描述它们之间转化流程。

我的答案：

Java堆 = 老年代 + 新生代
新生代 = Eden + S0 + S1
当 Eden 区的空间满了， Java虚拟机会触发一次 Minor GC，以收集新生代的垃圾，存活下来的对象，则会转移到 Survivor区。
大对象（需要大量连续内存空间的Java对象，如那种很长的字符串）直接进入老年态；
如果对象在Eden出生，并经过第一次Minor GC后仍然存活，并且被Survivor容纳的话，年龄设为1，每熬过一次Minor GC，年龄+1，若年龄超过一定限制（15），则被晋升到老年态。即长期存活的对象进入老年态。
老年代满了而无法容纳更多的对象，Minor GC 之后通常就会进行Full GC，Full GC 清理整个内存堆 – 包括年轻代和年老代。
Major GC 发生在老年代的GC，清理老年区，经常会伴随至少一次Minor GC，比Minor GC慢10倍以上。

##### 5.你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。

思路： 一定要记住典型的垃圾收集器，尤其cms和G1，它们的原理与区别，涉及的垃圾回收算法。

我的答案：

1）几种垃圾收集器：

Serial收集器： 单线程的收集器，收集垃圾时，必须stop the world，使用复制算法。
ParNew收集器： Serial收集器的多线程版本，也需要stop the world，复制算法。
Parallel Scavenge收集器： 新生代收集器，复制算法的收集器，并发的多线程收集器，目标是达到一个可控的吞吐量。如果虚拟机总共运行100分钟，其中垃圾花掉1分钟，吞吐量就是99%。
Serial Old收集器： 是Serial收集器的老年代版本，单线程收集器，使用标记整理算法。
Parallel Old收集器： 是Parallel Scavenge收集器的老年代版本，使用多线程，标记-整理算法。
CMS(Concurrent Mark Sweep) 收集器： 是一种以获得最短回收停顿时间为目标的收集器，标记清除算法，运作过程：初始标记，并发标记，重新标记，并发清除，收集结束会产生大量空间碎片。
G1收集器： 标记整理算法实现，运作流程主要包括以下：初始标记，并发标记，最终标记，筛选标记。不会产生空间碎片，可以精确地控制停顿。
2）CMS收集器和G1收集器的区别：

CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用；
G1收集器收集范围是老年代和新生代，不需要结合其他收集器使用；
CMS收集器以最小的停顿时间为目标的收集器；
G1收集器可预测垃圾回收的停顿时间
CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片
G1收集器使用的是“标记-整理”算法，进行了空间整合，降低了内存空间碎片。

##### 6.JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存。

 **思路：** 先画出Java内存模型图，结合例子volatile ，说明什么是重排序，内存屏障，最好能给面试官写以下demo说明。 

1) 什么是类加载器？

**类加载器** 就是根据指定全限定名称将class文件加载到JVM内存，转为Class对象。

2）双亲委派模型

**双亲委派模型工作过程是：**

3）为什么需要双亲委派模型？

在这里，先想一下，如果没有双亲委派，那么用户是不是可以自己定义一个java.lang.Object的同名类，java.lang.String的同名类，并把它放到ClassPath中,那么类之间的比较结果及类的唯一性将无法保证，因此，为什么需要双亲委派模型？防止内存中出现多份同样的字节码

##### 10.强引用、软引用、弱引用、虚引用的区别？

思路： 先说一下四种引用的定义，可以结合代码讲一下，也可以扩展谈到ThreadLocalMap里弱引用用处。

我的答案：

1）强引用

我们平时new了一个对象就是强引用，例如 Object obj = new Object();即使在内存不足的情况下，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。

2）软引用

如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。
用处： 软引用在实际中有重要的应用，例如浏览器的后退按钮。按后退时，这个后退时显示的网页内容是重新进行请求还是从缓存中取出呢？这就要看具体的实现策略了。

（1）如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构建

（2）如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出

3）弱引用

具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。

4）虚引用

如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动。

##### 垃圾回收算法 

 https://blog.csdn.net/iva_brother/article/details/87870576 

   ***\*引用计数法\****、***\*标记-清除法\****、***\*复制算法\****、***\*标记-清除算法\**** 





####  mysql

##### mysql 数据库引擎

  [mysql 数据库引擎](https://www.cnblogs.com/0201zcr/p/5296843.html)

 MYSQL引擎：  **INNODB** **ISAM、MYISAM和HEAP** 和**BERKLEY** 

##### **二十三、Mysql 中 MyISAM 和 InnoDB 的区别有哪些？**

1. InnoDB支持事务，MyISAM不支持

   对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；

2. InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；

3. InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。

   但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此主键不应该过大，因为主键太大，其他索引也都会很大。

   而MyISAM是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。

4. InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；

5. Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；

##### 索引类型

 https://www.cnblogs.com/xiao-lei/p/10957812.html 

普通索引： 这是最基本的索引，它没有任何限制 , 也是我们大多数情况下用到的索引。 

唯一索引：加速查询 + 列值唯一（可以有null）

主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个

组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并

全文索引：对文本的内容进行分词，进行搜索

##### 联合索引有效原则:

联合索引 abc  a和B, b和c可以击中索引么? 

ab 可以,bc不可

顾名思义是最左优先，以最左边的为起点任何连续的索引都能匹配上，
注：如果第一个字段是范围查询需要单独建一个索引
注：在创建联合索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。这样的话扩展性较好，比如 userid 经常需要作为查询条件，而 mobile 不常常用，则需要把 userid 放在联合索引的第一位置，即最左边

查询: **对于普通索引来说，，需要查找下一个记录，直到碰到第一个不满足** 

 https://www.cnblogs.com/wangchunli-blogs/p/10416046.html 



#### 线程池

##### 1、什么是线程池

java.util.concurrent.Executors提供了一个 java.util.concurrent.Executor接口的实现用于创建线程池

多线程技术主要解决处理器单元内多个线程执行的问题，它可以显著减少处理器单元的闲置时间，增加处理器单元的吞吐能力。
假设一个服务器完成一项任务所需时间为：T1 创建线程时间，T2 在线程中执行任务的时间，T3 销毁线程时间。

如果：T1 + T3 远大于 T2，则可以采用线程池，以提高服务器性能。

##### 2.常见线程池

 ThreadPoolExecutor创建线程池,而不是Executor 

①newSingleThreadExecutor
单个线程的线程池，即线程池中每次只有一个线程工作，单线程串行执行任务
②newFixedThreadExecutor(n)
固定数量的线程池，没提交一个任务就是一个线程，直到达到线程池的最大数量，然后后面进入等待队列直到前面的任务完成才继续执行
③newCacheThreadExecutor（推荐使用）
可缓存线程池，当线程池大小超过了处理任务所需的线程，那么就会回收部分空闲（一般是60秒无执行）的线程，当有任务来时，又智能的添加新线程来执行。
④newScheduleThreadExecutor
大小无限制的线程池，支持定时和周期性的执行线程

##### 3.常见参数

corePoolSize：核心线程数量，会一直存在，除非allowCoreThreadTimeOut设置为true
maximumPoolSize：线程池允许的最大线程池数量
keepAliveTime：线程数量超过corePoolSize，空闲线程的最大超时时间
unit：超时时间的单位
workQueue：工作队列，保存未执行的Runnable 任务
threadFactory：创建线程的工厂类
handler：当线程已满，工作队列也满了的时候，会被调用。被用来实现各种拒绝策略。

4. ##### 参数配置

最大线程池数量/ 核心线程数量  怎么配置

cpu密集型的任务 一般设置 线程数 = 核心数N + 1

 io密集型的任务 一般设置 线程数 = 核心数N*2 + 1

##### 线程池拒绝策略

 https://www.cnblogs.com/eric-fang/p/11584142.html 

 https://blog.csdn.net/wang_rrui/article/details/78541786 

1.CallerRunsPolicy - 当触发拒绝策略，只要线程池没有关闭的话，则使用调用线程直接运行任务。一般并发比较小，性能要求不高，不允许失败。但是，由于调用者自己运行任务，如果任务提交速度过快，可能导致程序阻塞，性能效率上必然的损失较大

2.AbortPolicy - 丢弃任务，并抛出拒绝执行 RejectedExecutionException 异常信息。线程池默认的拒绝策略。必须处理好抛出的异常，否则会打断当前的执行流程，影响后续的任务执行。

3.DiscardPolicy - 直接丢弃，其他啥都没有

4.DiscardOldestPolicy - 当触发拒绝策略，只要线程池没有关闭的话，丢弃阻塞队列 workQueue 中最老的一个任务，并将新任务加入

 

#### java锁/多线程

##### 1、说说线程安全问题，什么是线程安全，如何保证线程安全

- **线程安全**：就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。 线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据。
- 如何保证
  - 使用线程安全的类；
  - 使用synchronized同步代码块，或者用Lock锁；
  - 多线程并发情况下，线程共享的变量改为方法局部级变量

##### 2、重入锁的概念，重入锁为什么可以防止死锁

 https://www.jianshu.com/p/282440a29d78 

 java.util.concurrent.locks.ReentrantLock 

**概念**：自己可以获取自己的内部锁。当线程请求自己持有的对象锁时，如果锁是重入锁，线程请求成功。

**防止死锁原因**：

##### 3、产生死锁的四个条件

- **互斥**：某种资源一次只允许一个进程访问，即该资源一旦分配给某个进程，其他进程就不能再访问，直到该进程访问结束。
- **占有且等待**：一个进程本身占有资源（一种或多种），同时还有资源未得到满足，正在等待其他进程释放该资源。
- **不可抢占**：别人已经占有了某项资源，你不能因为自己也需要该资源，就去把别人的资源抢过来。
- **循环等待**：存在一个进程链，使得每个进程都占有下一个进程所需的至少一种资源。

参考：https://blog.csdn.net/guaiguaihenguai/article/details/80303835

##### 4、如何检查死锁

- 使用Jconsole,JDK自带的图形化界面。
- 使用jstack输出线程dump信息到文件。

以上两种方式请参考：http://www.cnblogs.com/flyingeagle/articles/6853167.html

##### 5、volatile 实现原理

 作用：使用volatile修饰的**成员变量**，就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性。

 原理：

- 强制把修改的数据写回内存。
- 在多处理器情况下使多处理器缓存的数据失效

##### 6、synchronized 实现原理

作用：确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。

原理：被synchronized 修饰的代码区，当线程想进入的时候，须先获取对象监视器（相当于钥匙，只存在一把），获取对象监视器成功的进入被修饰代码区，没有获取对象监视器的被阻塞在同步块和同步方法的入口处，进入`BLOCKED`状态。

##### 7、synchronized 与 lock 的区别

   获取Lock对象的方法：`Lock lock = ``new` `ReentrantLock();`

1. 首先synchronized是java内置关键字，在jvm层面，Lock是个java类；
2. synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；
3. synchronized会自动释放锁，Lock需在finally中手工释放锁（`lock.unlock()`方法释放锁），否则容易造成线程死锁；
4. 用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；
5. synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）
6. Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。
7. Lock锁可以设置等待时间，到了时间自动放弃获取锁

参考：https://www.cnblogs.com/iyyy/p/7993788.html

##### 8、AQS同步队列

  队列同步器。它是构建锁或者其他同步组件的基础框架，通过这个框架可以简单实现一些相关锁。

参考：https://www.cnblogs.com/wait-pigblog/archive/2018/07/16/9315700.html

##### 9、CAS无锁的概念、乐观锁和悲观锁

​    **概念**：CAS（compare and swap）是一种比较交换技术，可以用来鉴别线程技术，一旦检测到冲突就充当当前操作指导直到解决冲突。CAS机制中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。

   **乐观锁**：大多基于版本来实现。将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为提交的数据是过期数据。

   **悲观锁**：对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。
参考：https://blog.csdn.net/liubenlong007/article/details/53761730

##### 10、常见的原子操作类

java.util.concurrent.atomic包，这个包中的原子操作类，提供了一种用法简单，性能高效，线程安全的更新一个变量的方式。

AtomicInteger、AtomicLong、AtomicBoolean、AtomicIntegerArray、AtomicReference(引用类型)、AtomicIntegerFieldUpdater(原子更新整形属性的更新器)

##### 11、什么是ABA问题，出现ABA问题JDK是如何解决的

**ABA问题**：ABA问题出现在多线程或多进程计算环境中。

**ABA问题举例描述**：假设两个线程T1和T2访问同一个变量V，当T1访问变量V时，读取到V的值为A；此时线程T1被抢占了，T2开始执行，T2先将变量V的值从A变成了B，然后又将变量V从B变回了A；此时T1又抢占了主动权，继续执行，它发现变量V的值还是A，以为没有发生变化，所以就继续执行了。这个过程中，变量V从A变为B，再由B变为A就被形象地称为ABA问题了。

**JDK解决方式**：java提供了AtomicMarkableReference和AtomicStampedReference类帮助解决这个问题。AtomicStampedReference是利用版本戳的形式记录了每次改变以后的版本号

#####  12、乐观锁的业务场景及实现方式

**业务场景**：适合读取操作比较频繁的操作。

**实现方式**：使用版本标识的方式来确定读到的数据和提交的数据是否一致。提交后修改版本标识，当检测出不一致时就丢弃或重试。

##### 13、Java 8并法包下常见的并发类

ConcurrentHashMap、CopyOnWriteArrayList等

##### 14、偏向锁、轻量级锁、重量级锁、自旋锁的概念

- **偏向锁**：如果一个线程获得了锁，那么锁就进入了偏向模式。当这个线程再次请求锁时，无需再做任何同步操作。
- **轻量级锁**：简单的将对象头部作为指针，指向持有锁的线程堆栈的内部，来判断一个线程是否持有对象锁。
- **重量级锁**：
- **自旋锁**：轻量级锁就会膨胀为重量级锁后，虚拟机为了避免线程真实的在操作系统层面挂起，虚拟机还会在做最后的努力







####  nginx

##### 负载均衡的5种策略

 1.轮询（默认）
每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。 

2、指定权重

指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 

3、IP绑定 ip_hash

每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。

4、fair（第三方）

按后端服务器的响应时间来分配请求，响应时间短的优先分配。 

5、url_hash（第三方）

按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。 


####  springboot  springcloud

#####  自动配置原理/启动原理

@springboot Application 下有三个注解



@Confinature

 @EnableAutoConfiguration

@ compoentscan 



 引入了EnableAutoConfigurationImportSelector 类, 引入

@ configration

 @EnableConfigurationProperties(HttpEncodingProperties.class)

预先将属性添加到spring容器中,实现了自动配置 

#####  常用注解

@springbootApplication  

@enableAutoConfigration 

@servcie    @value @component 

##### 单元测试

  @RunWith(SpringRunner.class) 

  @SpringBootTest    

##### 禁用特定的自动配置类**  

exclude = 

#####  **什么是Spring boot  Actuator？它有什么优势？**  

  提供了web接口,允许我们对生产环境中的应用程序进行监视和管理。 

 

#####  spring Boot 热部署

 [maven 插件 springloaded](https://blog.csdn.net/xiaojin21cen/article/details/88312873#maven__springloaded_2) 

 [依赖 spring-boot-devtools 热部署模块](https://blog.csdn.net/xiaojin21cen/article/details/88312873#__springbootdevtools__52) 

####  springcloud 

##### 什么是spring cloud 

 Spring cloud流应用程序启动器是基于Spring Boot的Spring集成应用程序，提供与外部系统的集成。Spring cloud Task，一个生命周期短暂的微服务框架，用于快速构建执行有限数据处理的应用程序  

#####  五大组件

  Eureka 服务发现

  ribbon  负载均衡

  hystrix  断路器

  zuul      服务网关 

 fegin   服务间调用

  spring cloud config 分布式配置

#####  微服务的优缺点 

1 . 开发效率高/  低耦合, 面向接口编程,  易于第三方集成, 可以用不同的语言编写.灵活

2 .  保持数据一致性困难, 服务通信成本高, 性能监控困难

#####  *spring cloud 和dubbo区别?** 

1.服务调用方式 dubbo是RPC springcloud Rest Api
2.注册中心,dubbo 是zookeeper springcloud是eureka，也可以是zookeeper
3.服务网关,dubbo本身没有实现，只能通过其他第三方技术整合，springcloud有Zuul路由网关，作为路由服务器，进行消费者的请求分发,springcloud支持断路器，与git完美集成配置文件支持版本控制，事物总线实现配置文件的更新与服务自动装配等等一系列的微服务架构要素。
 **REST 和RPC对比** 

 1.RPC主要的缺陷是服务提供方和调用方式之间的依赖太强，需要对每一个微服务进行接口的定义，并通过持续继承发布，严格版本控制才不会出现冲突。
2.REST是轻量级的接口，服务的提供和调用不存在代码之间的耦合，只需要一个约定进行规范。 

 **Eureka和Zookeeper区别** 

 1.Eureka取CAP的AP，注重可用性，Zookeeper取CAP的CP注重
一致性。
2.Zookeeper在选举期间注册服务瘫痪，虽然服务最终会恢复，但选举期间不可用。
3.eureka的自我保护机制，会导致一个结果就是不会再从注册列表移除因长时间没收到心跳而过期的服务。依然能接受新服务的注册和查询请求，但不会被同步到其他节点。不会服务瘫痪。
4.Zookeeper有Leader和Follower角色，Eureka各个节点平等。
5.Zookeeper采用过半数存活原则，Eureka采用自我保护机制解决分区问题。
6.eureka本质是一个工程，Zookeeper只是一个进程。

 **eureka自我保护机制是什么?**
1.当Eureka Server 节点在短时间内丢失了过多实例的连接时（比如网络故障或频繁启动关闭客户端）节点会进入自我保护模式，保护注册信息，不再删除注册数据，故障恢复时，自动退出自我保护模式。 

什么是服务熔断？什么是服务降级?
服务直接的调用，比如在高并发情况下出现进程阻塞，导致当前线程不可用，慢慢的全部线程阻塞，导致服务器雪崩。
服务熔断：相当于保险丝，出现某个异常，直接熔断整个服务，而不是一直等到服务超时。通过维护一个自己的线程池，当线程到达阈值的时候就启动服务降级，如果其他请求继续访问就直接返回fallback的默认值。 

**什么是Ribbon？**
ribbon是一个负载均衡客户端，可以很好的控制htt和tcp的一些行为。feign默认集成了ribbon。 

 **什么是feigin？它的优点是什么？**
1.feign采用的是基于接口的注解
2.feign整合了ribbon，具有负载均衡的能力
3.整合了Hystrix，具有熔断的能力 

 使用:
1.添加pom依赖。
2.启动类添加@EnableFeignClients
3.定义一个接口@FeignClient(name=“xxx”)指定调用哪个服务 

##### Ribbon和Feign的区别？

1.Ribbon都是调用其他服务的，但方式不同。
2.启动类注解不同，Ribbon是@RibbonClient feign的是@EnableFeignClients
3.服务指定的位置不同，Ribbon是在@RibbonClient注解上声明，Feign则是在定义抽象方法的接口中使用@FeignClient声明。
4.调用方式不同，Ribbon需要自己构建http请求，模拟http请求然后使用RestTemplate发送给其他服务，步骤相当繁琐。Feign需要将调用的方法定义成抽象方法即可。

#####  什么是Spring Cloud Bus?

spring cloud bus 将分布式的节点用轻量的消息代理连接起来，它可以用于广播配置文件的更改或者服务直接的通讯，也可用于监控。
如果修改了配置文件，发送一次请求，所有的客户端便会重新读取配置文件。
使用:
1.添加依赖
2.配置rabbimq十六.springcloud断路器作用?
当一个服务调用另一个服务由于网络原因或自身原因出现问题，调用者就会等待被调用者的响应 当更多的服务请求到这些资源导致更多的请求等待，发生连锁效应（雪崩效应）
断路器有完全打开状态:一段时间内 达到一定的次数无法调用 并且多次监测没有恢复的迹象 断路器完全打开 那么下次请求就不会请求到该服务
半开:短时间内 有恢复迹象 断路器会将部分请求发给该服务，正常调用时 断路器关闭
关闭：当服务一直处于正常状态 能正常调用

##### 十七.什么是SpringCloudConfig?

在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。在Spring Cloud中，有分布式配置中心组件spring cloud config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库中。在spring cloud config 组件中，分两个角色，一是config server，二是config client。

使用：
1、添加pom依赖
2、配置文件添加相关配置
3、启动类添加注解@EnableConfigServer

##### 十八.Spring Cloud Gateway?

Spring Cloud Gateway是Spring Cloud官方推出的第二代网关框架，取代Zuul网关。网关作为流量的，在微服务系统中有着非常作用，网关常见的功能有路由转发、权限校验、限流控制等作用。

使用了一个RouteLocatorBuilder的bean去创建路由，除了创建路由RouteLocatorBuilder可以让你添加各种predicates和filters，predicates断言的意思，顾名思义就是根据具体的请求的规则，由具体的route去处理，filters是各种过滤器，用来对请求做各种判断和修改。

##### 十九.架构?

在微服务架构中，需要几个基础的服务治理组件，包括服务注册与发现、服务消费、负载均衡、断路器、智能路由、配置管理等，由这几个基础组件相互协作，共同组建了一个简单的微服务系统

在Spring Cloud微服务系统中，一种常见的负载均衡方式是，客户端的请求首先经过负载均衡（zuul、Ngnix），再到达服务网关（zuul集群），然后再到具体的服。，服务统一注册到高可用的服务注册中心集群，服务的所有的配置文件由配置服务管理，配置服务的配置文件放在git仓库，方便开发人员随时改配置。

##### 二十.什么是Hystrix?

防雪崩利器，具备服务降级，服务熔断，依赖隔离，监控（Hystrix Dashboard）
服务降级:
双十一 提示 哎哟喂，被挤爆了。 app秒杀 网络开小差了，请稍后再试。
优先核心服务，非核心服务不可用或弱可用。通过HystrixCommand注解指定。
fallbackMethod(回退函数)中具体实现降级逻辑。一.为什么要使用微服务？
1.随着互联网的快速发展，各行各业都在用互联网。互联网已经离不开人们的形形色色。随着越来越多的用户，业务场景也愈来愈复杂。
2.传统的单体架构已经很难满足互联网技术发展的要求，代码可维护性扩展性和可读性降低，维护成本的提高都是驱动微服务的发展趋势。

##### 二.作为服务注册中心，Eureka比Zookeeper好在哪里?

1.Eureka保证的是可用性和分区容错性，Zookeeper 保证的是一致性和分区容错性 。
2.Eureka还有一种自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障。而不会像zookeeper那样使整个注册服务瘫痪。

##### 三.什么是 Ribbon负载均衡？

1.Spring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端 负载均衡的工具。
2. Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。简单的说，就是在配置文件中列出Load Balancer（简称LB）后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随机连接等）去连接这些机器。我们也很容易使用Ribbon实现自定义的负载均衡算法。

##### 四.Ribbon负载均衡能干什么？

1.将用户的请求平摊的分配到多个服务上
2.集中式LB即在服务的消费方和提供方之间使用独立的LB设施(可以是硬件，如F5, 也可以是软件，如nginx), 由该设施负责把访问请求通过某种策略转发至服务的提供方；
3.进程内LB将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。

注意： Ribbon就属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。

##### 五.什么是 zuul路由网关

1.Zuul 包含了对请求的路由和过滤两个最主要的功能:其中路由功能负责将外部请求转发到具体的微服务实例上，是实现外部访问统一入口的基础而过滤器功能则负责对请求的处理过程进行干预，是实现请求校验、服务聚合等功能的基础、
2.Zuul和Eureka进行整合，将Zuul自身注册为Eureka服务治理下的应用，同时从Eureka中获得其他微服务的消息，也即以后的访问微服务都是通过Zuul跳转后获得。
注意： Zuul服务最终还是会注册进Eureka 提供=代理+路由+过滤 三大功能。

##### 六.分布式配置中心能干嘛？

1.集中管理配置文件不同环境不同配置，动态化的配置更新，分环境部署比如dev/test/prod/beta/release
2.运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息
3.当配置发生变动时，服务不需要重启即可感知到配置的变化并应用新的配置将配置信息以REST接口的形式暴露

##### 七.微服务的优缺点分别是什么？说下你在项目开发中碰到的坑？

这个问题感觉比较容易问到~~~~

优点:
1.每个服务足够内聚，足够小，代码容易理解这样能聚焦一个指定的业务功能或业务需求
2.开发简单、开发效率提高，一个服务可能就是专一的只干一件事。
3.微服务能够被小团队单独开发，这个小团队是2到5人的开发人员组成。
4.微服务是松耦合的，是有功能意义的服务，无论是在开发阶段或部署阶段都是独立的。
5.微服务能使用不同的语言开发。
6.易于和第三方集成，微服务允许容易且灵活的方式集成自动部署，通过持续集成工具，如Jenkins, Hudson, bamboo 。
7.微服务易于被一个开发人员理解，修改和维护，这样小团队能够更关注自己的工作成果。无需通过合作才能体现价值。
8.微服务允许你利用融合最新技术。
9.微服务只是业务逻辑的代码，不会和HTML,CSS 或其他界面组件混合。
10.每个微服务都有自己的存储能力，可以有自己的数据库。也可以有统一数据库。
缺点:
1.多服务运维难度，随着服务的增加，运维的压力也在增大
2.系统部署依赖
3.服务间通信成本
4.数据一致性
5.系统集成测试
6.性能监控

##### 八.什么是微服务？

1.微服务是一种架构模式或是一种架构风格，它提倡的是将单一的应用程序划分成若干个小的服务，每个服务都有独立的进程，服务之间相互协调，相互配合，最终完成目的。
2.服务之间采用轻量级的通信机制，通常是基于HTTP的TESTful API。
3.每个服务都围绕着具体业务进行构建，并且能够被独立地部署到生产环境、类生产环境等
4.应尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建，可以有一个非常轻量级的集中式管理来协调这些服务，可以使用不同的语言来编写服务，也可以使用不同的数据存储~
5.微服务化的核心就是将传统的一站式应用，根据业务拆分成一个一个的服务，彻底地去耦合,每一个微服务提供单个业务功能的服务，一个服务做一件事，从技术角度看就是一种小而独立的处理过程，类似进程概念，能够自行单独启动或销毁，拥有自己独立的数据库。

#### 分布式

#####  分布式技术特点 : 

 分片: 整个数据拆分成不同的小块 ,方便存储

 复制: 每个小块都有备份, 防止一台机器挂掉数据丢失 

  高可用:避免了单个主机 down掉导致整个系统崩溃 

#### MQ

##### 不同mq订阅模式的差异

> ?

 https://blog.csdn.net/maihilton/article/details/81628152 

##### mq的结构,怎么对消息做分发 

> ?

 https://blog.csdn.net/qq_30281559/article/details/100975860 

#####  RabbitMQ 

  

#### ElasticSearch

 https://www.cnblogs.com/luckcs/articles/7052932.html 

##### es底层 

 lucene 包含各种倒索引算法 

##### 倒排索引
 搜索引擎中,每个文档都有一个文档对应的id, 文档内容被表示为一系列关键词的集合。例如，文档 1 经过分词，提取了 20 个关键词，每个关键词都会记录它在文档中出现的次数和出现位置。

倒排索引就是关键词到文档 ID 的映射，每个关键词都对应着一系列的文件，这些文件中都出现了关键词。 

##### es的mapping

映射（mapping）
映射是定义一个文档以及其所包含的字段如何被存储和索引的方法。

例如，用映射来定义以下内容：

  哪些 string 类型的 field 应当被当成当成 full-text 字段
  哪些字段应该是数值类型、日期类型或者是地理位置信息
  日期类型字段的格式是怎么样的
  是否文档的所有字段都需要被索引到 _all 字段
  动态增加的 field 可以由用户自定义的模板来控制其行为 

##### es数据类型?

 https://www.cnblogs.com/shoufeng/p/10692113.html 

##### 精确检索 用什么数据类型

??

##### 模糊查询用什么数据类型

?? 

#####  为什么要使用到ES？

因为在我们商城中的数据，将来会非常多，所以采用以往的模糊查询，模糊查询前置配置，会放弃索引，导致商品查询是全表扫面，在百万级别的数据库中，效率非常低下，而我们使用ES做一个全文索引，我们将经常查询的商品的某些字段，比如说商品名，描述、价格还有id这些字段我们放入我们索引库里，可以提高查询速度。

##### Elasticsearch是如何实现Master选举的？

- Elasticsearch的选主是ZenDiscovery模块负责的，主要包含Ping（节点之间通过这个RPC来发现彼此）和Unicast（单播模块包含一个主机列表以控制哪些节点需要ping通）这两部分；

- 对所有可以成为master的节点（**node.master: true**）根据nodeId字典排序，每次选举每个节点都把自己所知道节点排一次序，然后选出第一个（第0位）节点，暂且认为它是master节点。

- 如果对某个节点的投票数达到一定的值（可以成为master节点数n/2+1）并且该节点自己也选举自己，那这个节点就是master。否则重新选举一直到满足上述条件。

- *补充：master节点的职责主要包括集群、节点和索引的管理，不负责文档级别的管理；data节点可以关闭http功能*。

  ##### Elasticsearch中的节点（比如共20个），其中的10个选了一个master，另外10个选了另一个master，怎么办？

- 当集群master候选数量不小于3个时，可以通过设置最少投票通过数量（**discovery.zen.minimum_master_nodes**）超过所有候选节点一半以上来解决脑裂问题；

- 当候选数量为两个时，只能修改为唯一的一个master候选，其他作为data节点，避免脑裂问题。

  ##### 客户端在和集群连接时，如何选择特定的节点执行请求的？

  TransportClient利用transport模块远程连接一个elasticsearch集群。它并不加入到集群中，只是简单的获得一个或者多个初始化的transport地址，并以 **轮询** 的方式与这些地址进行通信。

  

##### esmapping的数据类型

boolean,string ,byte,short  integer float double 

 date

##### es性能优化 

1. 索引效率优化 

   批量提交, 优化硬件,  增加refresh 写入时间间隔,减少副本数量 (默认3

2. 查询效率优化

   避免大分页, 一次小分页

3. jvm 设置

 不要超过32G
  不要把内存全部给 堆内存

 

##### es读数据

  可以通过 `doc id` 来查询，会根据 `doc id` 进行 hash，判断出来当时把 `doc id` 分配到了哪个 shard 上面去，从那个 shard 去查询。 

 客户端发送请求到任意一个 node，成为 `coordinate node`。 

 `coordinate node` 对 `doc id` 进行哈希路由，将请求转发到对应的 node，此时会使用 `round-robin`随机轮询算法，在 `primary shard` 以及其所有 replica 中随机选择一个，让读请求负载均衡。 

 接收请求的 node 返回 document 给 `coordinate node`。

 `coordinate node` 返回 document 给客户端。  

##### es 写数据过程

  客户端选择一个 node 发送请求过去，这个 node 就是 `coordinating node`（协调节点）。 

 `coordinating node` 对 document 进行路由，将请求转发给对应的 node（有 primary shard） 

 实际的 node 上的 `primary shard` 处理请求，然后将数据同步到 `replica node` 

 `coordinating node` 如果发现 `primary node` 和所有 `replica node` 都搞定之后，就返回响应结果给客户端。 

#### 框架

##### Spring的Bean的生命周期（大众版

1. 实例化Bean对象，这个时候Bean的对象是非常低级的，基本不能够被我们使用，因为连最基本的属性都没有设置，可以理解为连Autowired注解都是没有解析的；
2. 填充属性，当做完这一步，Bean对象基本是完整的了，可以理解为Autowired注解已经解析完毕，依赖注入完成了；
3. 如果Bean实现了BeanNameAware接口，则调用setBeanName方法；
4. 如果Bean实现了BeanClassLoaderAware接口，则调用setBeanClassLoader方法；
5. 如果Bean实现了BeanFactoryAware接口，则调用setBeanFactory方法；
6. 调用BeanPostProcessor的postProcessBeforeInitialization方法；
7. 如果Bean实现了InitializingBean接口，调用afterPropertiesSet方法；
8. 如果Bean定义了init-method方法，则调用Bean的init-method方法；
9. 调用BeanPostProcessor的postProcessAfterInitialization方法；当进行到这一步，Bean已经被准备就绪了，一直停留在应用的上下文中，直到被销毁；
10. 如果应用的上下文被销毁了，如果Bean实现了DisposableBean接口，则调用destroy方法，如果Bean定义了destory-method声明了销毁方法也会被调用。