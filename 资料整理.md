#### java锁/多线程

##### 1、说说线程安全问题，什么是线程安全，如何保证线程安全

- **线程安全**：就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。 线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据。
- 如何保证
  - 使用线程安全的类；
  - 使用synchronized同步代码块，或者用Lock锁；
  - 多线程并发情况下，线程共享的变量改为方法局部级变量

##### 2、重入锁的概念，重入锁为什么可以防止死锁

 https://www.jianshu.com/p/282440a29d78 

 java.util.concurrent.locks.ReentrantLock 

**概念**：自己可以获取自己的内部锁。当线程请求自己持有的对象锁时，如果锁是重入锁，线程请求成功。

**防止死锁原因**：

##### 3、产生死锁的四个条件

- **互斥**：某种资源一次只允许一个进程访问，即该资源一旦分配给某个进程，其他进程就不能再访问，直到该进程访问结束。
- **占有且等待**：一个进程本身占有资源（一种或多种），同时还有资源未得到满足，正在等待其他进程释放该资源。
- **不可抢占**：别人已经占有了某项资源，你不能因为自己也需要该资源，就去把别人的资源抢过来。
- **循环等待**：存在一个进程链，使得每个进程都占有下一个进程所需的至少一种资源。

参考：https://blog.csdn.net/guaiguaihenguai/article/details/80303835

##### 4、如何检查死锁

- 使用Jconsole,JDK自带的图形化界面。
- 使用jstack输出线程dump信息到文件。

以上两种方式请参考：http://www.cnblogs.com/flyingeagle/articles/6853167.html

##### 5、volatile 实现原理

 作用：使用volatile修饰的**成员变量**，就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性。

 原理：

- 强制把修改的数据写回内存。
- 在多处理器情况下使多处理器缓存的数据失效

##### 6、synchronized 实现原理

作用：确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。

原理：被synchronized 修饰的代码区，当线程想进入的时候，须先获取对象监视器（相当于钥匙，只存在一把），获取对象监视器成功的进入被修饰代码区，没有获取对象监视器的被阻塞在同步块和同步方法的入口处，进入`BLOCKED`状态。

##### 7、synchronized 与 lock 的区别

   获取Lock对象的方法：`Lock lock = ``new` `ReentrantLock();`

1. 首先synchronized是java内置关键字，在jvm层面，Lock是个java类；
2. synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；
3. synchronized会自动释放锁，Lock需在finally中手工释放锁（`lock.unlock()`方法释放锁），否则容易造成线程死锁；
4. 用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；
5. synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）
6. Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。
7. Lock锁可以设置等待时间，到了时间自动放弃获取锁

参考：https://www.cnblogs.com/iyyy/p/7993788.html

##### 8、AQS同步队列

  队列同步器。它是构建锁或者其他同步组件的基础框架，通过这个框架可以简单实现一些相关锁。

参考：https://www.cnblogs.com/wait-pigblog/archive/2018/07/16/9315700.html

##### 9、CAS无锁的概念、乐观锁和悲观锁

​    **概念**：CAS（compare and swap）是一种比较交换技术，可以用来鉴别线程技术，一旦检测到冲突就充当当前操作指导直到解决冲突。CAS机制中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。

   **乐观锁**：大多基于版本来实现。将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为提交的数据是过期数据。

   **悲观锁**：对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。
参考：https://blog.csdn.net/liubenlong007/article/details/53761730

##### 10、常见的原子操作类

java.util.concurrent.atomic包，这个包中的原子操作类，提供了一种用法简单，性能高效，线程安全的更新一个变量的方式。

AtomicInteger、AtomicLong、AtomicBoolean、AtomicIntegerArray、AtomicReference(引用类型)、AtomicIntegerFieldUpdater(原子更新整形属性的更新器)

##### 11、什么是ABA问题，出现ABA问题JDK是如何解决的

**ABA问题**：ABA问题出现在多线程或多进程计算环境中。

**ABA问题举例描述**：假设两个线程T1和T2访问同一个变量V，当T1访问变量V时，读取到V的值为A；此时线程T1被抢占了，T2开始执行，T2先将变量V的值从A变成了B，然后又将变量V从B变回了A；此时T1又抢占了主动权，继续执行，它发现变量V的值还是A，以为没有发生变化，所以就继续执行了。这个过程中，变量V从A变为B，再由B变为A就被形象地称为ABA问题了。

**JDK解决方式**：java提供了AtomicMarkableReference和AtomicStampedReference类帮助解决这个问题。AtomicStampedReference是利用版本戳的形式记录了每次改变以后的版本号

#####  12、乐观锁的业务场景及实现方式

**业务场景**：适合读取操作比较频繁的操作。

**实现方式**：使用版本标识的方式来确定读到的数据和提交的数据是否一致。提交后修改版本标识，当检测出不一致时就丢弃或重试。

##### 13、Java 8并法包下常见的并发类

ConcurrentHashMap、CopyOnWriteArrayList等

##### 14、偏向锁、轻量级锁、重量级锁、自旋锁的概念

- **偏向锁**：如果一个线程获得了锁，那么锁就进入了偏向模式。当这个线程再次请求锁时，无需再做任何同步操作。
- **轻量级锁**：简单的将对象头部作为指针，指向持有锁的线程堆栈的内部，来判断一个线程是否持有对象锁。
- **重量级锁**：
- **自旋锁**：轻量级锁就会膨胀为重量级锁后，虚拟机为了避免线程真实的在操作系统层面挂起，虚拟机还会在做最后的努力





####  MQ

 https://blog.csdn.net/qq_30281559/article/details/100975860 

####  springboot  springcloud

#####  自动配置原理/启动原理

@springboot Application 下有三个注解



@Confinature

 @EnableAutoConfiguration

@ compoentscan 



 引入了EnableAutoConfigurationImportSelector 类, 引入

@ configration

 @EnableConfigurationProperties(HttpEncodingProperties.class)

预先将属性添加到spring容器中,实现了自动配置 

#####  常用注解

@springbootApplication  

@enableAutoConfigration 

@servcie    @value @component 

##### 单元测试

  @RunWith(SpringRunner.class) 

  @SpringBootTest    

##### 禁用特定的自动配置类**  

exclude = 

#####  **什么是Spring boot  Actuator？它有什么优势？**  

  提供了web接口,允许我们对生产环境中的应用程序进行监视和管理。 

 

#####  spring Boot 热部署

 [maven 插件 springloaded](https://blog.csdn.net/xiaojin21cen/article/details/88312873#maven__springloaded_2) 

 [依赖 spring-boot-devtools 热部署模块](https://blog.csdn.net/xiaojin21cen/article/details/88312873#__springbootdevtools__52) 

####  springcloud 

##### 什么是spring cloud 

 Spring cloud流应用程序启动器是基于Spring Boot的Spring集成应用程序，提供与外部系统的集成。Spring cloud Task，一个生命周期短暂的微服务框架，用于快速构建执行有限数据处理的应用程序  

#####  五大组件

  Eureka 服务发现

  ribbon  负载均衡

  hystrix  断路器

  zuul      服务网关 

 fegin   服务间调用

  spring cloud config 分布式配置

#####  微服务的优缺点 

1 . 开发效率高/  低耦合, 面向接口编程,  易于第三方集成, 可以用不同的语言编写.灵活

2 .  保持数据一致性困难, 服务通信成本高, 性能监控困难

#####  *spring cloud 和dubbo区别?** 

1.服务调用方式 dubbo是RPC springcloud Rest Api
2.注册中心,dubbo 是zookeeper springcloud是eureka，也可以是zookeeper
3.服务网关,dubbo本身没有实现，只能通过其他第三方技术整合，springcloud有Zuul路由网关，作为路由服务器，进行消费者的请求分发,springcloud支持断路器，与git完美集成配置文件支持版本控制，事物总线实现配置文件的更新与服务自动装配等等一系列的微服务架构要素。
 **REST 和RPC对比** 

 1.RPC主要的缺陷是服务提供方和调用方式之间的依赖太强，需要对每一个微服务进行接口的定义，并通过持续继承发布，严格版本控制才不会出现冲突。
2.REST是轻量级的接口，服务的提供和调用不存在代码之间的耦合，只需要一个约定进行规范。 

 **Eureka和Zookeeper区别** 

 1.Eureka取CAP的AP，注重可用性，Zookeeper取CAP的CP注重
一致性。
2.Zookeeper在选举期间注册服务瘫痪，虽然服务最终会恢复，但选举期间不可用。
3.eureka的自我保护机制，会导致一个结果就是不会再从注册列表移除因长时间没收到心跳而过期的服务。依然能接受新服务的注册和查询请求，但不会被同步到其他节点。不会服务瘫痪。
4.Zookeeper有Leader和Follower角色，Eureka各个节点平等。
5.Zookeeper采用过半数存活原则，Eureka采用自我保护机制解决分区问题。
6.eureka本质是一个工程，Zookeeper只是一个进程。

 **eureka自我保护机制是什么?**
1.当Eureka Server 节点在短时间内丢失了过多实例的连接时（比如网络故障或频繁启动关闭客户端）节点会进入自我保护模式，保护注册信息，不再删除注册数据，故障恢复时，自动退出自我保护模式。 

什么是服务熔断？什么是服务降级?
服务直接的调用，比如在高并发情况下出现进程阻塞，导致当前线程不可用，慢慢的全部线程阻塞，导致服务器雪崩。
服务熔断：相当于保险丝，出现某个异常，直接熔断整个服务，而不是一直等到服务超时。通过维护一个自己的线程池，当线程到达阈值的时候就启动服务降级，如果其他请求继续访问就直接返回fallback的默认值。 

**什么是Ribbon？**
ribbon是一个负载均衡客户端，可以很好的控制htt和tcp的一些行为。feign默认集成了ribbon。 

 **什么是feigin？它的优点是什么？**
1.feign采用的是基于接口的注解
2.feign整合了ribbon，具有负载均衡的能力
3.整合了Hystrix，具有熔断的能力 

 使用:
1.添加pom依赖。
2.启动类添加@EnableFeignClients
3.定义一个接口@FeignClient(name=“xxx”)指定调用哪个服务 

##### Ribbon和Feign的区别？

1.Ribbon都是调用其他服务的，但方式不同。
2.启动类注解不同，Ribbon是@RibbonClient feign的是@EnableFeignClients
3.服务指定的位置不同，Ribbon是在@RibbonClient注解上声明，Feign则是在定义抽象方法的接口中使用@FeignClient声明。
4.调用方式不同，Ribbon需要自己构建http请求，模拟http请求然后使用RestTemplate发送给其他服务，步骤相当繁琐。Feign需要将调用的方法定义成抽象方法即可。

#####  什么是Spring Cloud Bus?

spring cloud bus 将分布式的节点用轻量的消息代理连接起来，它可以用于广播配置文件的更改或者服务直接的通讯，也可用于监控。
如果修改了配置文件，发送一次请求，所有的客户端便会重新读取配置文件。
使用:
1.添加依赖
2.配置rabbimq十六.springcloud断路器作用?
当一个服务调用另一个服务由于网络原因或自身原因出现问题，调用者就会等待被调用者的响应 当更多的服务请求到这些资源导致更多的请求等待，发生连锁效应（雪崩效应）
断路器有完全打开状态:一段时间内 达到一定的次数无法调用 并且多次监测没有恢复的迹象 断路器完全打开 那么下次请求就不会请求到该服务
半开:短时间内 有恢复迹象 断路器会将部分请求发给该服务，正常调用时 断路器关闭
关闭：当服务一直处于正常状态 能正常调用

##### 十七.什么是SpringCloudConfig?

在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。在Spring Cloud中，有分布式配置中心组件spring cloud config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库中。在spring cloud config 组件中，分两个角色，一是config server，二是config client。

使用：
1、添加pom依赖
2、配置文件添加相关配置
3、启动类添加注解@EnableConfigServer

##### 十八.Spring Cloud Gateway?

Spring Cloud Gateway是Spring Cloud官方推出的第二代网关框架，取代Zuul网关。网关作为流量的，在微服务系统中有着非常作用，网关常见的功能有路由转发、权限校验、限流控制等作用。

使用了一个RouteLocatorBuilder的bean去创建路由，除了创建路由RouteLocatorBuilder可以让你添加各种predicates和filters，predicates断言的意思，顾名思义就是根据具体的请求的规则，由具体的route去处理，filters是各种过滤器，用来对请求做各种判断和修改。

##### 十九.架构?

在微服务架构中，需要几个基础的服务治理组件，包括服务注册与发现、服务消费、负载均衡、断路器、智能路由、配置管理等，由这几个基础组件相互协作，共同组建了一个简单的微服务系统

在Spring Cloud微服务系统中，一种常见的负载均衡方式是，客户端的请求首先经过负载均衡（zuul、Ngnix），再到达服务网关（zuul集群），然后再到具体的服。，服务统一注册到高可用的服务注册中心集群，服务的所有的配置文件由配置服务管理，配置服务的配置文件放在git仓库，方便开发人员随时改配置。

##### 二十.什么是Hystrix?

防雪崩利器，具备服务降级，服务熔断，依赖隔离，监控（Hystrix Dashboard）
服务降级:
双十一 提示 哎哟喂，被挤爆了。 app秒杀 网络开小差了，请稍后再试。
优先核心服务，非核心服务不可用或弱可用。通过HystrixCommand注解指定。
fallbackMethod(回退函数)中具体实现降级逻辑。一.为什么要使用微服务？
1.随着互联网的快速发展，各行各业都在用互联网。互联网已经离不开人们的形形色色。随着越来越多的用户，业务场景也愈来愈复杂。
2.传统的单体架构已经很难满足互联网技术发展的要求，代码可维护性扩展性和可读性降低，维护成本的提高都是驱动微服务的发展趋势。

##### 二.作为服务注册中心，Eureka比Zookeeper好在哪里?

1.Eureka保证的是可用性和分区容错性，Zookeeper 保证的是一致性和分区容错性 。
2.Eureka还有一种自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障。而不会像zookeeper那样使整个注册服务瘫痪。

##### 三.什么是 Ribbon负载均衡？

1.Spring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端 负载均衡的工具。
2. Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。简单的说，就是在配置文件中列出Load Balancer（简称LB）后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随机连接等）去连接这些机器。我们也很容易使用Ribbon实现自定义的负载均衡算法。

##### 四.Ribbon负载均衡能干什么？

1.将用户的请求平摊的分配到多个服务上
2.集中式LB即在服务的消费方和提供方之间使用独立的LB设施(可以是硬件，如F5, 也可以是软件，如nginx), 由该设施负责把访问请求通过某种策略转发至服务的提供方；
3.进程内LB将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。

注意： Ribbon就属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。

##### 五.什么是 zuul路由网关

1.Zuul 包含了对请求的路由和过滤两个最主要的功能:其中路由功能负责将外部请求转发到具体的微服务实例上，是实现外部访问统一入口的基础而过滤器功能则负责对请求的处理过程进行干预，是实现请求校验、服务聚合等功能的基础、
2.Zuul和Eureka进行整合，将Zuul自身注册为Eureka服务治理下的应用，同时从Eureka中获得其他微服务的消息，也即以后的访问微服务都是通过Zuul跳转后获得。
注意： Zuul服务最终还是会注册进Eureka 提供=代理+路由+过滤 三大功能。

##### 六.分布式配置中心能干嘛？

1.集中管理配置文件不同环境不同配置，动态化的配置更新，分环境部署比如dev/test/prod/beta/release
2.运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息
3.当配置发生变动时，服务不需要重启即可感知到配置的变化并应用新的配置将配置信息以REST接口的形式暴露

##### 七.微服务的优缺点分别是什么？说下你在项目开发中碰到的坑？

这个问题感觉比较容易问到~~~~

优点:
1.每个服务足够内聚，足够小，代码容易理解这样能聚焦一个指定的业务功能或业务需求
2.开发简单、开发效率提高，一个服务可能就是专一的只干一件事。
3.微服务能够被小团队单独开发，这个小团队是2到5人的开发人员组成。
4.微服务是松耦合的，是有功能意义的服务，无论是在开发阶段或部署阶段都是独立的。
5.微服务能使用不同的语言开发。
6.易于和第三方集成，微服务允许容易且灵活的方式集成自动部署，通过持续集成工具，如Jenkins, Hudson, bamboo 。
7.微服务易于被一个开发人员理解，修改和维护，这样小团队能够更关注自己的工作成果。无需通过合作才能体现价值。
8.微服务允许你利用融合最新技术。
9.微服务只是业务逻辑的代码，不会和HTML,CSS 或其他界面组件混合。
10.每个微服务都有自己的存储能力，可以有自己的数据库。也可以有统一数据库。
缺点:
1.多服务运维难度，随着服务的增加，运维的压力也在增大
2.系统部署依赖
3.服务间通信成本
4.数据一致性
5.系统集成测试
6.性能监控

##### 八.什么是微服务？

1.微服务是一种架构模式或是一种架构风格，它提倡的是将单一的应用程序划分成若干个小的服务，每个服务都有独立的进程，服务之间相互协调，相互配合，最终完成目的。
2.服务之间采用轻量级的通信机制，通常是基于HTTP的TESTful API。
3.每个服务都围绕着具体业务进行构建，并且能够被独立地部署到生产环境、类生产环境等
4.应尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建，可以有一个非常轻量级的集中式管理来协调这些服务，可以使用不同的语言来编写服务，也可以使用不同的数据存储~
5.微服务化的核心就是将传统的一站式应用，根据业务拆分成一个一个的服务，彻底地去耦合,每一个微服务提供单个业务功能的服务，一个服务做一件事，从技术角度看就是一种小而独立的处理过程，类似进程概念，能够自行单独启动或销毁，拥有自己独立的数据库。

#### ElasticSearch

 https://www.cnblogs.com/luckcs/articles/7052932.html 

##### es底层 

 lucene 包含各种倒索引算法 

##### 倒排索引
 搜索引擎中,每个文档都有一个文档对应的id, 文档内容被表示为一系列关键词的集合。例如，文档 1 经过分词，提取了 20 个关键词，每个关键词都会记录它在文档中出现的次数和出现位置。

倒排索引就是关键词到文档 ID 的映射，每个关键词都对应着一系列的文件，这些文件中都出现了关键词。 

##### es的mapping

映射（mapping）
映射是定义一个文档以及其所包含的字段如何被存储和索引的方法。

例如，用映射来定义以下内容：

  哪些 string 类型的 field 应当被当成当成 full-text 字段
  哪些字段应该是数值类型、日期类型或者是地理位置信息
  日期类型字段的格式是怎么样的
  是否文档的所有字段都需要被索引到 _all 字段
  动态增加的 field 可以由用户自定义的模板来控制其行为 

#####  为什么要使用到ES？

因为在我们商城中的数据，将来会非常多，所以采用以往的模糊查询，模糊查询前置配置，会放弃索引，导致商品查询是全表扫面，在百万级别的数据库中，效率非常低下，而我们使用ES做一个全文索引，我们将经常查询的商品的某些字段，比如说商品名，描述、价格还有id这些字段我们放入我们索引库里，可以提高查询速度。

##### Elasticsearch是如何实现Master选举的？

- Elasticsearch的选主是ZenDiscovery模块负责的，主要包含Ping（节点之间通过这个RPC来发现彼此）和Unicast（单播模块包含一个主机列表以控制哪些节点需要ping通）这两部分；

- 对所有可以成为master的节点（**node.master: true**）根据nodeId字典排序，每次选举每个节点都把自己所知道节点排一次序，然后选出第一个（第0位）节点，暂且认为它是master节点。

- 如果对某个节点的投票数达到一定的值（可以成为master节点数n/2+1）并且该节点自己也选举自己，那这个节点就是master。否则重新选举一直到满足上述条件。

- *补充：master节点的职责主要包括集群、节点和索引的管理，不负责文档级别的管理；data节点可以关闭http功能*。

  ##### Elasticsearch中的节点（比如共20个），其中的10个选了一个master，另外10个选了另一个master，怎么办？

- 当集群master候选数量不小于3个时，可以通过设置最少投票通过数量（**discovery.zen.minimum_master_nodes**）超过所有候选节点一半以上来解决脑裂问题；

- 当候选数量为两个时，只能修改为唯一的一个master候选，其他作为data节点，避免脑裂问题。

  ##### 客户端在和集群连接时，如何选择特定的节点执行请求的？

  TransportClient利用transport模块远程连接一个elasticsearch集群。它并不加入到集群中，只是简单的获得一个或者多个初始化的transport地址，并以 **轮询** 的方式与这些地址进行通信。

  

##### esmapping的数据类型

boolean,string ,byte,short  integer float double 

 date

##### es性能优化 

1. 索引效率优化 

   批量提交, 优化硬件,  增加refresh 写入时间间隔,减少副本数量 (默认3

2. 查询效率优化

   避免大分页, 一次小分页

3. jvm 设置

 不要超过32G
  不要把内存全部给 堆内存

 

##### es读数据

  可以通过 `doc id` 来查询，会根据 `doc id` 进行 hash，判断出来当时把 `doc id` 分配到了哪个 shard 上面去，从那个 shard 去查询。 

 客户端发送请求到任意一个 node，成为 `coordinate node`。 

 `coordinate node` 对 `doc id` 进行哈希路由，将请求转发到对应的 node，此时会使用 `round-robin`随机轮询算法，在 `primary shard` 以及其所有 replica 中随机选择一个，让读请求负载均衡。 

 接收请求的 node 返回 document 给 `coordinate node`。

 `coordinate node` 返回 document 给客户端。  

##### es 写数据过程

  客户端选择一个 node 发送请求过去，这个 node 就是 `coordinating node`（协调节点）。 

 `coordinating node` 对 document 进行路由，将请求转发给对应的 node（有 primary shard） 

 实际的 node 上的 `primary shard` 处理请求，然后将数据同步到 `replica node` 

 `coordinating node` 如果发现 `primary node` 和所有 `replica node` 都搞定之后，就返回响应结果给客户端。 

#### 框架

##### Spring的Bean的生命周期（大众版

1. 实例化Bean对象，这个时候Bean的对象是非常低级的，基本不能够被我们使用，因为连最基本的属性都没有设置，可以理解为连Autowired注解都是没有解析的；
2. 填充属性，当做完这一步，Bean对象基本是完整的了，可以理解为Autowired注解已经解析完毕，依赖注入完成了；
3. 如果Bean实现了BeanNameAware接口，则调用setBeanName方法；
4. 如果Bean实现了BeanClassLoaderAware接口，则调用setBeanClassLoader方法；
5. 如果Bean实现了BeanFactoryAware接口，则调用setBeanFactory方法；
6. 调用BeanPostProcessor的postProcessBeforeInitialization方法；
7. 如果Bean实现了InitializingBean接口，调用afterPropertiesSet方法；
8. 如果Bean定义了init-method方法，则调用Bean的init-method方法；
9. 调用BeanPostProcessor的postProcessAfterInitialization方法；当进行到这一步，Bean已经被准备就绪了，一直停留在应用的上下文中，直到被销毁；
10. 如果应用的上下文被销毁了，如果Bean实现了DisposableBean接口，则调用destroy方法，如果Bean定义了destory-method声明了销毁方法也会被调用。