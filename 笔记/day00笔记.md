## day01

 ~~~
关键字：在程序中，自己定义的名字，比如方法名，变量名。
常量： 值在java中固定不变的值（整数常量，小数常量，字符常量，字符串常量，布尔常量，空常量）
 ~~~

## day02

三元运算符

Int  a  =（a>b? 100:200）

~~~
7.分析以下需求，并用代码实现：
	(1)已知一个三位数，请分别获取该三位数上每一位的数值
	(2)例如：123的个位、十位、百位，分别是3、2、1
	(3)打印格式"数字123的个位是 3, 十位是 2, 百位是 1"

//百位
System.out.println( a/100 ); 
//十位
System.out.println( a/10%10);
//个位
System.out.println( a%10 );
~~~

~~~
int的取值范围：
int b1=2147483647
Int的取值范围是2^31   十位数
~~~

# 

## day3

 ~~~
打印素数：
// 这道题是完全通过试错试出来的。 
public class SuUu{
	public static void main(String[] args){
	for(int i = 2 ;i<100;i++){
	  for(int j = 2 ;j<i; j++){
		  if(i%j == 0 && i != j){
			   break;
/* i=  7
   j= 2,3,4,5,6
 */
		  }
		 if(i%j == 0 && i ==j){}
		    System.out.println(i);
	  }	}
}

 ~~~

~~~
算法2：时间复杂度O(n)
public class IsPrime {
    public boolean isPrime(int a) {
        int count = 0;
        for (int i = 1; i <= a; i++) {
            if (a % i == 0) {
                count++;
            }
       }
        if (count == 2) {
            return true;
        } else {
            return false;
            }
    }
}
~~~





## day05  数组

jvm的区域划分

| 区域名称   |               作用                |
| ------ | :-----------------------------: |
| ------ |              -----              |
| 寄存器    |         给CPU使用，和我们开发无关。         |
| 本地方法栈  |   JVM在使用操作系统功能的时候使用，和我们开发无关。    |
| 方法区    |         存储可以运行的class文件          |
| 堆内存    |    存储对象或者数组，new来创建的，都存储在堆内存     |
| 方法栈    | 方法运行时使用的内存，比如main方法运行，进入方法栈中执行。 |

## day6 面向对象

//??? 对象内存图？？

堆？ 栈？ 方法？

## day8 String类，static关键字，ArrayList

static关键字：

~~~
 //?????   属于类的？而不是属于对象的？
 它可以用来修饰的成员变量和成员方法，被修饰的成员是属于类的，而不是单单是属于某个对象的。也就是说，既然属于类，就可以不靠创建对象来调用了。
 
~~~

类变量：使用static 关键字修饰的成员变量

~~~
当 static 修饰成员变量时，该变量称为类变量。该类的每个对象都共享同一个类变量的值。任何对象都可以更改。
该类变量的值，但也可以在不创建该类的对象的情况下对类变量进行操作
~~~



## day9

abstract 抽象类

~~~
使用 abstract 关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体
~~~

~~~
抽象类
如果一个类包含抽象方法，那么该类必须是抽象类。
abstract class 类名字{}
~~~

~~~
1. 抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。
理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。
2. 抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。
理解：子类的构造方法中，有默认的super()，需要访问父类构造方法。
3.  抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。
理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设
计
4.  抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类
理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义
~~~

## day10 接口和多态

 

~~~
多态的体现：
父类类型 变量名 = new 子类对象；
变量名.方法名();
父类引用指向子类对象。 
~~~

